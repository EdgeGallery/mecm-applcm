"""
# Copyright 2021 21CN Corporation Limited
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
# -*- coding: utf-8 -*-
import copy
import logging

logger = logging.getLogger()


def translate(app_description, sw_image_map):
    """
    翻译tosca为hot
    Args:
        app_description: tosca模板
        sw_image_map: 镜像名称id映射

    Returns: hot

    """
    hot = {
        'heat_template_version': '2016-10-14',
        'description': 'Generated By OsPlugin',
        'parameters': {},
        'resources': {},
        'outputs': {}
    }
    topology_template = app_description['topology_template']

    # 翻译 参数声明
    hot['parameters'] = translate_inputs(topology_template['inputs'])

    # 翻译 节点声明
    node_templates = topology_template['node_templates']
    for name, node_template in node_templates.items():
        resource_translator = NODE_TEMPLATE_MAPPER[node_template['type']]
        resource_translator(node_template,
                            app_d=app_description,
                            hot=hot,
                            node_name=name,
                            sw_image_map=sw_image_map)

    # 翻译 组声明
    groups = topology_template['groups']
    for name, group in groups.items():
        group_translator = GROUP_MAPPER[group['type']]
        group_translator(group,
                         app_d=app_description,
                         hot=hot,
                         node_name=name)

    # 翻译 策略声明
    policies = topology_template['policies']
    for policy_obj in policies:
        name = next(iter(policy_obj.keys()))
        policy = policy_obj[name]
        policy_translator = POLICY_MAPPER[policy['type']]
        policy_translator(policy, app_d=app_description, hot=hot, node_name=name)

    # 翻译 函数
    for resource in hot['resources'].values():
        translate_function(resource['properties'])

    return hot


def translate_inputs(inputs):
    """
    把 inputs 翻译为 parameters
    hot不支持text、password类型参数，翻译为string
    Args:
        inputs: tosca参数模版

    Returns: parameters

    """
    parameters = copy.deepcopy(inputs)
    for key in parameters.keys():
        if parameters[key]['type'] == 'text' or parameters[key]['type'] == 'password':
            parameters[key]['type'] = 'string'
    return parameters


def translate_vdu_compute(node_template, **kwargs):
    resource = {
        'type': 'OS::Nova::Server',
        'properties': {}
    }
    data_mapping(ComputeMapper, node_template, resource['properties'], **kwargs)
    node_templates = kwargs['app_d']['topology_template']['node_templates']
    resource['properties']['networks'] = []
    for node_name, node_template in node_templates.items():
        if node_template['type'] != 'tosca.nodes.nfv.VduCp':
            continue
        if 'requirements' not in node_template:
            continue
        for requirement in node_template['requirements']:
            if 'virtual_binding' not in requirement:
                continue
            if kwargs['node_name'] != requirement['virtual_binding']:
                continue
            resource['properties']['networks'].append({
                'port': {
                    'get_resource': node_name
                }
            })

    kwargs['hot']['resources'][kwargs['node_name']] = resource
    return resource


def translate_vdu_cp(node_template, **kwargs):
    resource = {
        'type': 'OS::Neutron::Port',
        'properties': {}
    }
    data_mapping(VduCpMapper, node_template, resource['properties'], **kwargs)

    security_groups = []
    for name, group in kwargs['app_d']['topology_template']['groups'].items():
        if group['type'] != 'tosca.groups.nfv.PortSecurityGroup':
            continue
        if kwargs['node_name'] not in set(group['members']):
            continue
        security_groups.append({
            'get_resource': name
        })
    if len(security_groups) > 0:
        resource['properties']['security_groups'] = security_groups

    kwargs['hot']['resources'][kwargs['node_name']] = resource
    return resource


def translate_vl(node_template, **kwargs):
    """
    网络不通过heat创建，翻译为neutron network
    Args:
        node_template: 网络模板
        **kwargs: 其他

    Returns: neutron network

    """
    network = {}
    data_mapping(VnfVirtualLinkMapper, node_template, network, **kwargs)
    subnets = network.pop('subnets', [])
    virtual_link = {'network': network, 'subnets': subnets}

    if 'inputs' in kwargs:
        inputs = kwargs['inputs']
        parameters = getattr(kwargs, 'parameters', None)
        set_inputs(virtual_link, inputs, parameters)
    return virtual_link


def translate_virtual_storage(node_template, **kwargs):
    resource = {
        'type': 'OS::Cinder::Volume',
        'properties': {}
    }
    data_mapping(VirtualStorageMapper, node_template, resource['properties'], **kwargs)

    kwargs['hot']['resources'][kwargs['node_name']] = resource
    return resource


def translate_port_security_group(group, **kwargs):
    resource = {
        'type': 'OS::Neutron::SecurityGroup',
        'properties': {
            'rules': [{
                'remote_mode': 'remote_group_id'
            }]
        }
    }
    data_mapping(SecurityGroupMapper, group, resource['properties'], **kwargs)

    kwargs['hot']['resources'][kwargs['node_name']] = resource
    return resource


def translate_security_group_rule(policy, **kwargs):
    resource = {
        'type': 'OS::Neutron::SecurityGroupRule',
        'properties': {}
    }
    data_mapping(SecurityGroupRuleMapper, policy, resource['properties'], **kwargs)
    rule_name = kwargs['node_name']
    resources = kwargs['hot']['resources']
    for group_name in policy['targets']:
        resources[group_name + '_rule_' + rule_name] = copy.deepcopy(resource)
        resources[group_name + '_rule_' + rule_name]['properties']['security_group'] = {
            'get_resource': group_name
        }


def translate_function(properties):
    """
    翻译函数名称和实现
    目前支持的函数
    get_input: 翻译为 get_param ，参数列表不变
    concat: 翻译为 list_join ，参数列表变更为 ['', 原参数]
    其他函数有需求可实现
    Args:
        properties: 可能包含函数的obj对象

    Returns:

    """
    if isinstance(properties, dict):
        if 'get_input' in properties:
            properties['get_param'] = properties.pop('get_input')
        if 'concat' in properties:
            properties['list_join'] = ['', properties.pop('concat')]
        for value in properties.values():
            translate_function(value)

    elif isinstance(properties, list):
        for item in properties:
            translate_function(item)


def translate_unknown(unknown, **kwargs):
    """
    跳过翻译不支持的类型
    Args:
        unknown: 类型数据
        **kwargs: 其他

    Returns:

    """
    logger.info('skip translate unknown type %s', unknown['type'])


def set_inputs(properties, inputs, parameters):
    """
    把get_input函数替换为实际值
    Args:
        properties:
        inputs:
        parameters:

    Returns:

    """
    if isinstance(properties, dict):
        for sub_key, sub_value in properties.items():
            if 'get_input' in sub_value:
                properties[sub_key] = get_from_inputs(sub_value['get_input'], inputs, parameters)
            else:
                set_inputs(sub_value, inputs, parameters)
    elif isinstance(properties, list):
        for item in properties:
            set_inputs(item, inputs, parameters)


def get_from_inputs(key, inputs, parameters):
    """
    获取根据参数名称获取参数值
    如果没有传入参数值，则从默认值中获取
    Args:
        key: 参数名称
        inputs: 定义参数的dict，包含默认值
        parameters: 参数值列表

    Returns:

    """
    if parameters and key in parameters:
        return parameters[key]
    default_input = getattr(inputs, key, {'default': None})
    return default_input['default']


NODE_TEMPLATE_MAPPER = {
    'tosca.nodes.nfv.VNF': translate_unknown,
    'tosca.nodes.nfv.Vdu.Compute': translate_vdu_compute,
    'tosca.nodes.nfv.Vdu.VirtualStorage': translate_virtual_storage,
    'tosca.nodes.nfv.VduCp': translate_vdu_cp,
    'tosca.nodes.nfv.Cp': translate_unknown,
    'tosca.nodes.nfv.VnfVirtualLink': translate_unknown,
    'tosca.nodes.nfv.app.configuration': translate_unknown
}

GROUP_MAPPER = {
    'tosca.groups.nfv.PlacementGroup': translate_unknown,
    'tosca.groups.nfv.PortSecurityGroup': translate_port_security_group
}

POLICY_MAPPER = {
    'tosca.policies.nfv.AffinityRule': translate_unknown,
    'tosca.policies.nfv.AntiAffinityRule': translate_unknown,
    'tosca.policies.nfv.SecurityGroupRule': translate_security_group_rule
}


class MappingAction(object):
    """
    描述映射时的行为
    """
    def __init__(self, key):
        """
        指定映射目标
        Args:
            key:
        """
        self.key = key

    def do_action(self, data, properties, **kwargs):
        """
        执行映射动作
        Args:
            data: 映射元数据
            properties: 目标
            **kwargs:

        Returns:

        """
        pass


class SetAction(MappingAction):
    """
    把一个字段映射到目标字段
    """
    def do_action(self, data, properties, **kwargs):
        properties[self.key] = data


class FunctionAction(MappingAction):
    """
    把一个字段映射到目标函数
    """
    def do_action(self, data, properties, **kwargs):
        self.key(data, properties, **kwargs)


class AppendAction(MappingAction):
    """
    把一个字段映射到目标数组
    """
    def do_action(self, data, properties, **kwargs):
        if self.key['key'] not in properties:
            properties[self.key['key']] = []
        if 'value' in self.key:
            item = {self.key['value']: data}
            properties[self.key['key']].append(item)
        else:
            properties[self.key].append(data)


def map_virtual_compute(virtual_compute, properties, **kwargs):
    """
    把 tosca.capabilities.nfv.VirtualCompute 映射为OS::Nova::Flavor
    Args:
        virtual_compute: tosca.capabilities.nfv.VirtualCompute对象
        properties: 所属 OS::Nova::Server 对象
        **kwargs:

    Returns:

    """
    resource = {
        'type': 'OS::Nova::Flavor',
        'properties': {}
    }
    data_mapping(VirtualComputeMapper, virtual_compute, resource['properties'], **kwargs)
    flavor_node_name = kwargs['node_name'] + '_FLAVOR'
    if flavor_node_name in kwargs['hot']['resources']:
        kwargs['hot']['resources'][flavor_node_name].update(resource['properties'])
    else:
        kwargs['hot']['resources'][flavor_node_name] = resource
    properties['flavor'] = {
        'get_resource': flavor_node_name
    }


def map_vdu_profile(vdu_profile, properties, **kwargs):
    """
    映射资源调度配置
    Args:
        vdu_profile:
        properties:
        **kwargs:

    Returns:

    """
    if 'flavor_extra_specs' not in vdu_profile:
        return

    resource = {
        'type': 'OS::Nova::Flavor',
        'properties': {
            'extra_specs': {}
        }
    }
    flavor_extra_specs = vdu_profile['flavor_extra_specs']
    for key in flavor_extra_specs:
        if isinstance(flavor_extra_specs[key], bool):
            resource['properties']['extra_specs'][key] = 'true' \
                if flavor_extra_specs[key] else 'false'
        elif isinstance(flavor_extra_specs[key], (int, float)):
            resource['properties']['extra_specs'][key] = str(flavor_extra_specs[key])
        else:
            resource['properties']['extra_specs'][key] = flavor_extra_specs[key]

    flavor_node_name = kwargs['node_name'] + '_FLAVOR'

    if flavor_node_name in kwargs['hot']['resources']:
        kwargs['hot']['resources'][flavor_node_name].update(resource['properties'])
    else:
        kwargs['hot']['resources'][flavor_node_name] = resource


def map_user_data(user_data, properties, **kwargs):
    """
    映射用户初始化数据
    Args:
        user_data:
        properties:

    Returns:

    """
    if user_data['contents'] == '':
        return
    if len(user_data['params'].keys()) == 0:
        properties['user_data'] = user_data['contents']
        return
    params = {}
    for key in user_data['params'].keys():
        params[f'${key}$'] = user_data['params'][key]
    properties['user_data'] = {
        'str_replace': {
            'params': params,
            'template': user_data['contents']
        }
    }


def map_sw_image_data(sw_image_data, properties, **kwargs):
    """
    映射镜像
    Args:
        sw_image_data:
        properties:
        **kwargs:

    Returns:

    """
    sw_image_map = kwargs['sw_image_map']
    if sw_image_data['name'] not in sw_image_map:
        properties['image'] = sw_image_data['name']
        return

    properties['image'] = sw_image_map[sw_image_data['name']]['id']


def map_virtual_storage(requirement, properties, **kwargs):
    """
    映射云盘绑定
    Args:
        requirement:
        properties:
        **kwargs:

    Returns:

    """
    block_device_mapping_v2 = {
        'delete_on_termination': True,
        'volume_id': {
            'get_resource': requirement
        }
    }
    node_templates = kwargs['app_d']['topology_template']['node_templates']

    if requirement in node_templates:
        block_storage = node_templates[requirement]['properties']
        sw_image_map = kwargs['sw_image_map']

        if 'sw_image_data' in block_storage and \
                block_storage['sw_image_data']['name'] in sw_image_map and \
                sw_image_map[block_storage['sw_image_data']['name']]['format'] == 'iso':
            block_device_mapping_v2['boot_index'] = 1
            block_device_mapping_v2['device_type'] = 'cdrom'

    if 'block_device_mapping_v2' not in properties:
        properties['block_device_mapping_v2'] = []
    properties['block_device_mapping_v2'].append(block_device_mapping_v2)


def map_virtual_link(requirement, properties, **kwargs):
    """
    映射网络绑定
    Args:
        requirement:
        properties:
        **kwargs:

    Returns:

    """
    node_templates = kwargs['app_d']['topology_template']['node_templates']

    if requirement in node_templates:
        virtual_link = node_templates[requirement]['properties']
        network_name = virtual_link['vl_profile']['network_name']
        properties['network'] = network_name


def map_l3_protocol_data(l3_protocol_data, properties, **kwargs):
    """
    映射3层网络配置
    Args:
        l3_protocol_data:
        properties:
        **kwargs:

    Returns:

    """
    subnets = []
    for data in l3_protocol_data:
        subnet = {}
        data_mapping(VnfVirtualLinkL3Mapper, data, subnet, **kwargs)
        subnets.append(subnet)
    if len(subnets) > 0:
        properties['subnets'] = subnets


def map_ip_allocation_pools(ip_allocation_pools, properties, **kwargs):
    properties['allocation_pools'] = []
    for ip_allocation_pool in ip_allocation_pools:
        properties['allocation_pools'].append({
            'start': ip_allocation_pool['start_ip_address'],
            'end': ip_allocation_pool['end_ip_address']
        })


ComputeMapper = {
    'properties.name': SetAction('name'),
    'properties.nfvi_constraints': SetAction('availability_zone'),
    'properties.bootdata.user_data': FunctionAction(map_user_data),
    'properties.bootdata.config_drive': SetAction('config_drive'),
    'properties.vdu_profile': FunctionAction(map_vdu_profile),
    'properties.sw_image_data': FunctionAction(map_sw_image_data),
    'capabilities.virtual_compute': FunctionAction(map_virtual_compute),
    'requirements.%d.virtual_storage': FunctionAction(map_virtual_storage)
}

VirtualComputeMapper = {
    'properties.virtual_cpu.num_virtual_cpu': SetAction('vcpus'),
    'properties.virtual_memory.virtual_mem_size': SetAction('ram'),
    'properties.virtual_local_storage.size_of_storage': SetAction('disk'),
}

VduCpMapper = {
    'properties.vnic_type': SetAction('binding:vnic_type'),
    'properties.port_security_enabled': SetAction('port_security_enabled'),
    'attributes.ipv4_address': AppendAction({'key': 'fixed_ips', 'value': 'ip_address'}),
    'attributes.ipv6_address': AppendAction({'key': 'fixed_ips', 'value': 'ip_address'}),
    'attributes.mac': SetAction('mac_address'),
    'requirements.%d.virtual_link': FunctionAction(map_virtual_link),
}

VirtualStorageMapper = {
    'properties.virtual_storage_data.size_of_storage': SetAction('size'),
    'properties.virtual_storage_data.volume_type.volume_type_name': SetAction('volume_type'),
    'properties.sw_image_data': FunctionAction(map_sw_image_data),
    'properties.nfvi_constraints': SetAction('availability_zone')
}

VnfVirtualLinkMapper = {
    'properties.vl_profile.network_name': SetAction('name'),
    'properties.vl_profile.network_type': SetAction('provider:network_type'),
    'properties.vl_profile.physical_network': SetAction('provider:physical_network'),
    'properties.vl_profile.provider_segmentation_id': SetAction('provider:segmentation_id'),
    'properties.vl_profile.router_external': SetAction('router:external'),
    'properties.vl_profile.vlan_transparent': SetAction('vlan_transparent'),
    'properties.vl_profile.l3_protocol_data': FunctionAction(map_l3_protocol_data)
}

VnfVirtualLinkL3Mapper = {
    'properties.name': SetAction('name'),
    'properties.ip_version': SetAction('ip_version'),
    'properties.cidr': SetAction('cidr'),
    'properties.ip_allocation_pools': FunctionAction(map_ip_allocation_pools),
    'properties.gateway_ip': SetAction('gateway_ip'),
    'properties.dhcp_enabled': SetAction('enable_dhcp'),
    'properties.ipv6_ra_mode': SetAction('ipv6_ra_mode'),
    'properties.ipv6_address_mode': SetAction('ipv6_address_mode'),
    'properties.host_routes': SetAction('host_routes'),
    'properties.dns_name_servers': SetAction('dns_nameservers')
}

SecurityGroupMapper = {
    'properties.description': SetAction('description'),
    'properties.name': SetAction('name'),
}

SecurityGroupRuleMapper = {
    'properties.description': SetAction('description'),
    'properties.direction': SetAction('direction'),
    'properties.ether_type': SetAction('ether_type'),
    'properties.protocol': SetAction('protocol'),
    'properties.port_range_min': SetAction('port_range_min'),
    'properties.port_range_max': SetAction('port_range_max'),
    'properties.remote_ip_prefix': SetAction('remote_ip_prefix')
}


def data_mapping(map_dict, template, properties, **kwargs):
    for key, item in template.items():
        sub_data_mapping(map_dict, key, item, properties, **kwargs)


def sub_data_mapping(map_dict, f_key, sub_data, properties, **kwargs):
    if f_key in map_dict:
        map_dict[f_key].do_action(sub_data, properties, **kwargs)
    elif isinstance(sub_data, dict):
        for key, item in sub_data.items():
            sub_data_mapping(map_dict, f_key + '.' + key, item, properties, **kwargs)
    elif isinstance(sub_data, list):
        for item in sub_data:
            sub_data_mapping(map_dict, f_key + '.%d', item, properties, **kwargs)
    else:
        logger.debug('skip unknown key %s', f_key)
